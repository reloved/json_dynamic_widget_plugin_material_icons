// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'json_material_icon_builder.dart';

// **************************************************************************
// Generator: JsonWidgetLibraryBuilder
// **************************************************************************

// ignore_for_file: avoid_init_to_null
// ignore_for_file: deprecated_member_use

// ignore_for_file: prefer_const_constructors
// ignore_for_file: prefer_const_constructors_in_immutables
// ignore_for_file: prefer_final_locals
// ignore_for_file: prefer_if_null_operators
// ignore_for_file: prefer_single_quotes
// ignore_for_file: unused_local_variable

class JsonMaterialIconBuilder extends _JsonMaterialIconBuilder {
  const JsonMaterialIconBuilder({required super.args});

  static const kType = 'material_icon';

  /// Constant that can be referenced for the builder's type.
  @override
  String get type => kType;

  /// Static function that is capable of decoding the widget from a dynamic JSON
  /// or YAML set of values.
  static JsonMaterialIconBuilder fromDynamic(
    dynamic map, {
    JsonWidgetRegistry? registry,
  }) =>
      JsonMaterialIconBuilder(
        args: map,
      );

  @override
  JsonMaterialIconBuilderModel createModel({
    ChildWidgetBuilder? childBuilder,
    required JsonWidgetData data,
  }) {
    final model = JsonMaterialIconBuilderModel.fromDynamic(
      args,
      registry: data.jsonWidgetRegistry,
    );

    return model;
  }

  @override
  Icon buildCustom({
    ChildWidgetBuilder? childBuilder,
    required BuildContext context,
    required JsonWidgetData data,
    Key? key,
  }) {
    final model = createModel(
      childBuilder: childBuilder,
      data: data,
    );

    final iconDecoded = _decodeIcon(
      value: model.icon,
    );

    return Icon(
      iconDecoded,
      applyTextScaling: model.applyTextScaling,
      blendMode: model.blendMode,
      color: model.color,
      fill: model.fill,
      fontWeight: model.fontWeight,
      grade: model.grade,
      key: key,
      opticalSize: model.opticalSize,
      semanticLabel: model.semanticLabel,
      shadows: model.shadows,
      size: model.size,
      textDirection: model.textDirection,
      weight: model.weight,
    );
  }
}

class JsonMaterialIcon extends JsonWidgetData {
  JsonMaterialIcon(
    this.icon, {
    Map<String, dynamic> args = const {},
    JsonWidgetRegistry? registry,
    this.applyTextScaling,
    this.blendMode,
    this.color,
    this.fill,
    this.fontWeight,
    this.grade,
    this.opticalSize,
    this.semanticLabel,
    this.shadows,
    this.size,
    this.textDirection,
    this.weight,
  }) : super(
          jsonWidgetArgs: JsonMaterialIconBuilderModel.fromDynamic(
            {
              'applyTextScaling': applyTextScaling,
              'blendMode': blendMode,
              'color': color,
              'fill': fill,
              'fontWeight': fontWeight,
              'grade': grade,
              'icon': icon,
              'opticalSize': opticalSize,
              'semanticLabel': semanticLabel,
              'shadows': shadows,
              'size': size,
              'textDirection': textDirection,
              'weight': weight,
              ...args,
            },
            args: args,
            registry: registry,
          ),
          jsonWidgetBuilder: () => JsonMaterialIconBuilder(
            args: JsonMaterialIconBuilderModel.fromDynamic(
              {
                'applyTextScaling': applyTextScaling,
                'blendMode': blendMode,
                'color': color,
                'fill': fill,
                'fontWeight': fontWeight,
                'grade': grade,
                'icon': icon,
                'opticalSize': opticalSize,
                'semanticLabel': semanticLabel,
                'shadows': shadows,
                'size': size,
                'textDirection': textDirection,
                'weight': weight,
                ...args,
              },
              args: args,
              registry: registry,
            ),
          ),
          jsonWidgetType: JsonMaterialIconBuilder.kType,
        );

  /* AUTOGENERATED FROM [Icon.applyTextScaling]*/
  /// Whether to scale the size of this widget using the ambient [MediaQuery]'s [TextScaler].
  ///
  /// This is specially useful when you have an icon associated with a text, as
  /// scaling the text without scaling the icon would result in a confusing
  /// interface.
  ///
  /// Defaults to the nearest [IconTheme]'s
  /// [IconThemeData.applyTextScaling].
  final bool? applyTextScaling;

  /* AUTOGENERATED FROM [Icon.blendMode]*/
  /// The [BlendMode] to apply to the foreground of the icon.
  ///
  /// Defaults to [BlendMode.srcOver]
  final BlendMode? blendMode;

  /* AUTOGENERATED FROM [Icon.color]*/
  /// The color to use when drawing the icon.
  ///
  /// Defaults to the nearest [IconTheme]'s [IconThemeData.color].
  ///
  /// The color (whether specified explicitly here or obtained from the
  /// [IconTheme]) will be further adjusted by the nearest [IconTheme]'s
  /// [IconThemeData.opacity].
  ///
  /// {@tool snippet}
  /// Typically, a Material Design color will be used, as follows:
  ///
  /// ```dart
  /// Icon(
  ///   Icons.widgets,
  ///   color: Colors.blue.shade400,
  /// )
  /// ```
  /// {@end-tool}
  final Color? color;

  /* AUTOGENERATED FROM [Icon.fill]*/
  /// The fill for drawing the icon.
  ///
  /// Requires the underlying icon font to support the `FILL` [FontVariation]
  /// axis, otherwise has no effect. Variable font filenames often indicate
  /// the supported axes. Must be between 0.0 (unfilled) and 1.0 (filled),
  /// inclusive.
  ///
  /// Can be used to convey a state transition for animation or interaction.
  ///
  /// Defaults to nearest [IconTheme]'s [IconThemeData.fill].
  ///
  /// See also:
  ///  * [weight], for controlling stroke weight.
  ///  * [grade], for controlling stroke weight in a more granular way.
  ///  * [opticalSize], for controlling optical size.
  final double? fill;

  /* AUTOGENERATED FROM [Icon.fontWeight]*/
  /// The typeface thickness to use when painting the text (e.g., bold).
  final FontWeight? fontWeight;

  /* AUTOGENERATED FROM [Icon.grade]*/
  /// The grade (granular stroke weight) for drawing the icon.
  ///
  /// Requires the underlying icon font to support the `GRAD` [FontVariation]
  /// axis, otherwise has no effect. Variable font filenames often indicate
  /// the supported axes. Can be negative.
  ///
  /// Grade and [weight] both affect a symbol's stroke weight (thickness), but
  /// grade has a smaller impact on the size of the symbol.
  ///
  /// Grade is also available in some text fonts. One can match grade levels
  /// between text and symbols for a harmonious visual effect. For example, if
  /// the text font has a -25 grade value, the symbols can match it with a
  /// suitable value, say -25.
  ///
  /// Defaults to nearest [IconTheme]'s [IconThemeData.grade].
  ///
  /// See also:
  ///  * [fill], for controlling fill.
  ///  * [weight], for controlling stroke weight in a less granular way.
  ///  * [opticalSize], for controlling optical size.
  ///  * https://fonts.google.com/knowledge/glossary/grade_axis
  final double? grade;

  /* AUTOGENERATED FROM [Icon.icon]*/
  /// The icon to display. The available icons are described in [Icons].
  ///
  /// The icon can be null, in which case the widget will render as an empty
  /// space of the specified [size].
  final dynamic icon;

  /* AUTOGENERATED FROM [Icon.opticalSize]*/
  /// The optical size for drawing the icon.
  ///
  /// Requires the underlying icon font to support the `opsz` [FontVariation]
  /// axis, otherwise has no effect. Variable font filenames often indicate
  /// the supported axes. Must be greater than 0.
  ///
  /// For an icon to look the same at different sizes, the stroke weight
  /// (thickness) must change as the icon size scales. Optical size offers a way
  /// to automatically adjust the stroke weight as icon size changes.
  ///
  /// Defaults to nearest [IconTheme]'s [IconThemeData.opticalSize].
  ///
  /// See also:
  ///  * [fill], for controlling fill.
  ///  * [weight], for controlling stroke weight.
  ///  * [grade], for controlling stroke weight in a more granular way.
  ///  * https://fonts.google.com/knowledge/glossary/optical_size_axis
  final double? opticalSize;

  /* AUTOGENERATED FROM [Icon.semanticLabel]*/
  /// Semantic label for the icon.
  ///
  /// Announced by assistive technologies (e.g TalkBack/VoiceOver).
  /// This label does not show in the UI.
  ///
  ///  * [SemanticsProperties.label], which is set to [semanticLabel] in the
  ///    underlying	 [Semantics] widget.
  final String? semanticLabel;

  /* AUTOGENERATED FROM [Icon.shadows]*/
  /// A list of [Shadow]s that will be painted underneath the icon.
  ///
  /// Multiple shadows are supported to replicate lighting from multiple light
  /// sources.
  ///
  /// Shadows must be in the same order for [Icon] to be considered as
  /// equivalent as order produces differing transparency.
  ///
  /// Defaults to the nearest [IconTheme]'s [IconThemeData.shadows].
  final List<Shadow>? shadows;

  /* AUTOGENERATED FROM [Icon.size]*/
  /// The size of the icon in logical pixels.
  ///
  /// Icons occupy a square with width and height equal to size.
  ///
  /// Defaults to the nearest [IconTheme]'s [IconThemeData.size].
  ///
  /// If this [Icon] is being placed inside an [IconButton], then use
  /// [IconButton.iconSize] instead, so that the [IconButton] can make the splash
  /// area the appropriate size as well. The [IconButton] uses an [IconTheme] to
  /// pass down the size to the [Icon].
  final double? size;

  /* AUTOGENERATED FROM [Icon.textDirection]*/
  /// The text direction to use for rendering the icon.
  ///
  /// If this is null, the ambient [Directionality] is used instead.
  ///
  /// Some icons follow the reading direction. For example, "back" buttons point
  /// left in left-to-right environments and right in right-to-left
  /// environments. Such icons have their [IconData.matchTextDirection] field
  /// set to true, and the [Icon] widget uses the [textDirection] to determine
  /// the orientation in which to draw the icon.
  ///
  /// This property has no effect if the [icon]'s [IconData.matchTextDirection]
  /// field is false, but for consistency a text direction value must always be
  /// specified, either directly using this property or using [Directionality].
  final TextDirection? textDirection;

  /* AUTOGENERATED FROM [Icon.weight]*/
  /// The stroke weight for drawing the icon.
  ///
  /// Requires the underlying icon font to support the `wght` [FontVariation]
  /// axis, otherwise has no effect. Variable font filenames often indicate
  /// the supported axes. Must be greater than 0.
  ///
  /// Defaults to nearest [IconTheme]'s [IconThemeData.weight].
  ///
  /// See also:
  ///  * [fill], for controlling fill.
  ///  * [grade], for controlling stroke weight in a more granular way.
  ///  * [opticalSize], for controlling optical size.
  ///  * https://fonts.google.com/knowledge/glossary/weight_axis
  final double? weight;
}

/* AUTOGENERATED FROM [Icon]*/
/// Creates an icon.
class JsonMaterialIconBuilderModel extends JsonWidgetBuilderModel {
  const JsonMaterialIconBuilderModel(
    super.args, {
    this.applyTextScaling,
    this.blendMode,
    this.color,
    this.fill,
    this.fontWeight,
    this.grade,
    required this.icon,
    this.opticalSize,
    this.semanticLabel,
    this.shadows,
    this.size,
    this.textDirection,
    this.weight,
  });

  /* AUTOGENERATED FROM [Icon.applyTextScaling]*/
  /// Whether to scale the size of this widget using the ambient [MediaQuery]'s [TextScaler].
  ///
  /// This is specially useful when you have an icon associated with a text, as
  /// scaling the text without scaling the icon would result in a confusing
  /// interface.
  ///
  /// Defaults to the nearest [IconTheme]'s
  /// [IconThemeData.applyTextScaling].
  final bool? applyTextScaling;

  /* AUTOGENERATED FROM [Icon.blendMode]*/
  /// The [BlendMode] to apply to the foreground of the icon.
  ///
  /// Defaults to [BlendMode.srcOver]
  final BlendMode? blendMode;

  /* AUTOGENERATED FROM [Icon.color]*/
  /// The color to use when drawing the icon.
  ///
  /// Defaults to the nearest [IconTheme]'s [IconThemeData.color].
  ///
  /// The color (whether specified explicitly here or obtained from the
  /// [IconTheme]) will be further adjusted by the nearest [IconTheme]'s
  /// [IconThemeData.opacity].
  ///
  /// {@tool snippet}
  /// Typically, a Material Design color will be used, as follows:
  ///
  /// ```dart
  /// Icon(
  ///   Icons.widgets,
  ///   color: Colors.blue.shade400,
  /// )
  /// ```
  /// {@end-tool}
  final Color? color;

  /* AUTOGENERATED FROM [Icon.fill]*/
  /// The fill for drawing the icon.
  ///
  /// Requires the underlying icon font to support the `FILL` [FontVariation]
  /// axis, otherwise has no effect. Variable font filenames often indicate
  /// the supported axes. Must be between 0.0 (unfilled) and 1.0 (filled),
  /// inclusive.
  ///
  /// Can be used to convey a state transition for animation or interaction.
  ///
  /// Defaults to nearest [IconTheme]'s [IconThemeData.fill].
  ///
  /// See also:
  ///  * [weight], for controlling stroke weight.
  ///  * [grade], for controlling stroke weight in a more granular way.
  ///  * [opticalSize], for controlling optical size.
  final double? fill;

  /* AUTOGENERATED FROM [Icon.fontWeight]*/
  /// The typeface thickness to use when painting the text (e.g., bold).
  final FontWeight? fontWeight;

  /* AUTOGENERATED FROM [Icon.grade]*/
  /// The grade (granular stroke weight) for drawing the icon.
  ///
  /// Requires the underlying icon font to support the `GRAD` [FontVariation]
  /// axis, otherwise has no effect. Variable font filenames often indicate
  /// the supported axes. Can be negative.
  ///
  /// Grade and [weight] both affect a symbol's stroke weight (thickness), but
  /// grade has a smaller impact on the size of the symbol.
  ///
  /// Grade is also available in some text fonts. One can match grade levels
  /// between text and symbols for a harmonious visual effect. For example, if
  /// the text font has a -25 grade value, the symbols can match it with a
  /// suitable value, say -25.
  ///
  /// Defaults to nearest [IconTheme]'s [IconThemeData.grade].
  ///
  /// See also:
  ///  * [fill], for controlling fill.
  ///  * [weight], for controlling stroke weight in a less granular way.
  ///  * [opticalSize], for controlling optical size.
  ///  * https://fonts.google.com/knowledge/glossary/grade_axis
  final double? grade;

  /* AUTOGENERATED FROM [Icon.icon]*/
  /// The icon to display. The available icons are described in [Icons].
  ///
  /// The icon can be null, in which case the widget will render as an empty
  /// space of the specified [size].
  final dynamic icon;

  /* AUTOGENERATED FROM [Icon.opticalSize]*/
  /// The optical size for drawing the icon.
  ///
  /// Requires the underlying icon font to support the `opsz` [FontVariation]
  /// axis, otherwise has no effect. Variable font filenames often indicate
  /// the supported axes. Must be greater than 0.
  ///
  /// For an icon to look the same at different sizes, the stroke weight
  /// (thickness) must change as the icon size scales. Optical size offers a way
  /// to automatically adjust the stroke weight as icon size changes.
  ///
  /// Defaults to nearest [IconTheme]'s [IconThemeData.opticalSize].
  ///
  /// See also:
  ///  * [fill], for controlling fill.
  ///  * [weight], for controlling stroke weight.
  ///  * [grade], for controlling stroke weight in a more granular way.
  ///  * https://fonts.google.com/knowledge/glossary/optical_size_axis
  final double? opticalSize;

  /* AUTOGENERATED FROM [Icon.semanticLabel]*/
  /// Semantic label for the icon.
  ///
  /// Announced by assistive technologies (e.g TalkBack/VoiceOver).
  /// This label does not show in the UI.
  ///
  ///  * [SemanticsProperties.label], which is set to [semanticLabel] in the
  ///    underlying	 [Semantics] widget.
  final String? semanticLabel;

  /* AUTOGENERATED FROM [Icon.shadows]*/
  /// A list of [Shadow]s that will be painted underneath the icon.
  ///
  /// Multiple shadows are supported to replicate lighting from multiple light
  /// sources.
  ///
  /// Shadows must be in the same order for [Icon] to be considered as
  /// equivalent as order produces differing transparency.
  ///
  /// Defaults to the nearest [IconTheme]'s [IconThemeData.shadows].
  final List<Shadow>? shadows;

  /* AUTOGENERATED FROM [Icon.size]*/
  /// The size of the icon in logical pixels.
  ///
  /// Icons occupy a square with width and height equal to size.
  ///
  /// Defaults to the nearest [IconTheme]'s [IconThemeData.size].
  ///
  /// If this [Icon] is being placed inside an [IconButton], then use
  /// [IconButton.iconSize] instead, so that the [IconButton] can make the splash
  /// area the appropriate size as well. The [IconButton] uses an [IconTheme] to
  /// pass down the size to the [Icon].
  final double? size;

  /* AUTOGENERATED FROM [Icon.textDirection]*/
  /// The text direction to use for rendering the icon.
  ///
  /// If this is null, the ambient [Directionality] is used instead.
  ///
  /// Some icons follow the reading direction. For example, "back" buttons point
  /// left in left-to-right environments and right in right-to-left
  /// environments. Such icons have their [IconData.matchTextDirection] field
  /// set to true, and the [Icon] widget uses the [textDirection] to determine
  /// the orientation in which to draw the icon.
  ///
  /// This property has no effect if the [icon]'s [IconData.matchTextDirection]
  /// field is false, but for consistency a text direction value must always be
  /// specified, either directly using this property or using [Directionality].
  final TextDirection? textDirection;

  /* AUTOGENERATED FROM [Icon.weight]*/
  /// The stroke weight for drawing the icon.
  ///
  /// Requires the underlying icon font to support the `wght` [FontVariation]
  /// axis, otherwise has no effect. Variable font filenames often indicate
  /// the supported axes. Must be greater than 0.
  ///
  /// Defaults to nearest [IconTheme]'s [IconThemeData.weight].
  ///
  /// See also:
  ///  * [fill], for controlling fill.
  ///  * [grade], for controlling stroke weight in a more granular way.
  ///  * [opticalSize], for controlling optical size.
  ///  * https://fonts.google.com/knowledge/glossary/weight_axis
  final double? weight;

  static JsonMaterialIconBuilderModel fromDynamic(
    dynamic map, {
    Map<String, dynamic> args = const {},
    JsonWidgetRegistry? registry,
  }) {
    final result = maybeFromDynamic(
      map,
      args: args,
      registry: registry,
    );

    if (result == null) {
      throw Exception(
        '[JsonMaterialIconBuilder]: requested to parse from dynamic, but the input is null.',
      );
    }

    return result;
  }

  static JsonMaterialIconBuilderModel? maybeFromDynamic(
    dynamic map, {
    Map<String, dynamic> args = const {},
    JsonWidgetRegistry? registry,
  }) {
    JsonMaterialIconBuilderModel? result;

    if (map != null) {
      if (map is String) {
        map = yaon.parse(
          map,
          normalize: true,
        );
      }

      if (map is JsonMaterialIconBuilderModel) {
        result = map;
      } else {
        registry ??= JsonWidgetRegistry.instance;
        map = registry.processArgs(map, <String>{}).value;
        result = JsonMaterialIconBuilderModel(
          args,
          applyTextScaling: JsonClass.maybeParseBool(
            map['applyTextScaling'],
          ),
          blendMode: () {
            dynamic parsed = ThemeDecoder.decodeBlendMode(
              map['blendMode'],
              validate: false,
            );

            return parsed;
          }(),
          color: () {
            dynamic parsed = ThemeDecoder.decodeColor(
              map['color'],
              validate: false,
            );

            return parsed;
          }(),
          fill: () {
            dynamic parsed = JsonClass.maybeParseDouble(map['fill']);

            return parsed;
          }(),
          fontWeight: () {
            dynamic parsed = ThemeDecoder.decodeFontWeight(
              map['fontWeight'],
              validate: false,
            );

            return parsed;
          }(),
          grade: () {
            dynamic parsed = JsonClass.maybeParseDouble(map['grade']);

            return parsed;
          }(),
          icon: map['icon'],
          opticalSize: () {
            dynamic parsed = JsonClass.maybeParseDouble(map['opticalSize']);

            return parsed;
          }(),
          semanticLabel: map['semanticLabel'],
          shadows: map['shadows'],
          size: () {
            dynamic parsed = JsonClass.maybeParseDouble(map['size']);

            return parsed;
          }(),
          textDirection: () {
            dynamic parsed = ThemeDecoder.decodeTextDirection(
              map['textDirection'],
              validate: false,
            );

            return parsed;
          }(),
          weight: () {
            dynamic parsed = JsonClass.maybeParseDouble(map['weight']);

            return parsed;
          }(),
        );
      }
    }

    return result;
  }

  @override
  Map<String, dynamic> toJson() {
    final iconEncoded = _JsonMaterialIconBuilder._encodeIcon(icon);

    return JsonClass.removeNull({
      'applyTextScaling': applyTextScaling,
      'blendMode': ThemeEncoder.encodeBlendMode(
        blendMode,
      ),
      'color': ThemeEncoder.encodeColor(
        color,
      ),
      'fill': fill,
      'fontWeight': ThemeEncoder.encodeFontWeight(
        fontWeight,
      ),
      'grade': grade,
      'icon': iconEncoded,
      'opticalSize': opticalSize,
      'semanticLabel': semanticLabel,
      'shadows': shadows,
      'size': size,
      'textDirection': ThemeEncoder.encodeTextDirection(
        textDirection,
      ),
      'weight': weight,
      ...args,
    });
  }
}

class MaterialIconSchema {
  static const id =
      'https://peiffer-innovations.github.io/flutter_json_schemas/schemas/json_dynamic_widget_plugin_material_icons/material_icon.json';

  static final schema = <String, Object>{
    r'$schema': 'http://json-schema.org/draft-07/schema#',
    r'$id': id,
    'title': 'MaterialIcon',
    'type': 'object',
    'additionalProperties': false,
    'properties': {
      'applyTextScaling': SchemaHelper.boolSchema,
      'blendMode': SchemaHelper.objectSchema(BlendModeSchema.id),
      'color': SchemaHelper.objectSchema(ColorSchema.id),
      'fill': SchemaHelper.numberSchema,
      'fontWeight': SchemaHelper.objectSchema(FontWeightSchema.id),
      'grade': SchemaHelper.numberSchema,
      'icon': SchemaHelper.objectSchema(IconDataSchema.id),
      'opticalSize': SchemaHelper.numberSchema,
      'semanticLabel': SchemaHelper.stringSchema,
      'shadows': SchemaHelper.anySchema,
      'size': SchemaHelper.numberSchema,
      'textDirection': SchemaHelper.objectSchema(TextDirectionSchema.id),
      'weight': SchemaHelper.numberSchema,
    },
    'required': [
      'icon',
    ],
  };
}
